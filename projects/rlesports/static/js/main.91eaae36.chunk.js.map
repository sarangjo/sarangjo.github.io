{"version":3,"sources":["util.ts","constants.ts","viz/SimpleGraph.tsx","data/sample/players.ts","types/index.ts","viz/Timeline.tsx","viz/Text.tsx","viz/Sankey.tsx","viz/Table.tsx","viz/ForceGraph.tsx","forces.ts","data/sample/seasons.ts","data/sample/team-colors.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Viz","getNodeId","indices","join","tournamentsToPlayerNodes","d3","x","d","y","curve","tournaments","reduce","acc1","tournament","tournamentIndex","concat","teams","acc2","team","teamIndex","players","acc3","_player","playerIndex","id","getPlayerName","simpleY","playersPerTeam","buffer","tournamentAcronym","name","replaceAll","VizTitle","SANKEY","TEAM_MAP","FORCE_GRAPH","SIMPLE","TABLE","TEXT","TIMELINE","toDate","moment","getTeamColor","ScaleTimeDisjoint","domain","range","dateDiffs","totalDiff","this","map","r","diff","input","output","some","i","totalX","localDiff","findPlayer","tname","player","find","p","toLowerCase","alternateIDs","console","log","tournamentMap","seasons","func","acc","s","sectionsMapped","sections","sec","t","getColorByBackground","hex","c","length","parseInt","g","b","a","hexToColor","process","index","prevTourn","overflowIndex","size","indexPairs","newIndex","prevTeam","prevTeamIndex","intersection","originalIndex","sortedIndexPairs","sortBy","newTeams","forEach","pair","push","metadata","JSON","stringify","sort","allNodes","inverseMap","nodes","links","source","target","SimpleGraph","scaleLinear","WIDTH","getD","sx","sy","tx","ty","xmid","ymid","data","width","height","key","cx","cy","textAnchor","CIRCLE_RADIUS","fill","stroke","Region","EventType","PLAYERS","memberships","leave","Radius","JOIN","LEAVE","Timeline","teamColors","idx","myPart","myIndex","warn","error","assign","getIndices","getY","pname","_eventNum","_eventType","start","cur","end","candidate","format","scaleTime","MARGIN","BIG_WIDTH","TimelineDate","now","transform","TournamentComponent","thisX","thisWidth","opacity","TIMELINE_BUFFER","myY","isNull","m","STROKE_WIDTH_TEAM","PlayerComponent","elements","mem","color","joinX","joinY","circ","data-date","SPACING","prevLeaveX","prevLeaveY","x1","y1","x2","y2","leaveX","leaveY","strokeWidth","days","add","Fragment","Text","useMemo","processed","seasonMap","seasonCounts","style","textAlign","Math","round","rookies","rookiePercentage","j","k","ordinalSuffixOf","sum","values","average","backgroundColor","interpolateOrRd","findTeamForPlayer","tourney","get","sankeyCreator","sankey","nodeId","nodeWidth","nodePadding","nodeAlign","nodeSort","startsWith","linkSort","Sankey","allPlayers","Set","minDate","maxDate","date","slice","tournamentPlayers","value","delete","processTournaments","className","sankeyLinkHorizontal","strokeOpacity","y0","x0","NODE_WIDTH","fontSize","textLength","lengthAdjust","Table","seasonsData","season","playerBlocks","section","tourneyDone","has","region","blocks","max","fullStart","min","fullEnd","last","playerNames","Array","from","keys","Y_OFFSET","sIndex","baseX","isNaN","playerData","dates","relevantTourney","WORLD","scale","indexOf","startX","convert","endX","PADDING","PLAYER_HEIGHT","ForceGraph","update","useUpdate","useState","dragNode","setDragNode","origin","setOrigin","setStart","playerNodes","playerLinks","processPlayerLinks","simulation","force","distance","strength","HEIGHT","getVel","desiredY","node","alpha","sameTeamNodes","partition","filter","n","velosUp","arr","fy","velosDown","delVy","vy","initialize","_","arguments","sameTeamForce","differentTeamNodes","differentTeamForce","on","handleStartDrag","e","alphaTarget","restart","clientX","clientY","fx","onMouseMove","onMouseUp","clamp","onMouseDown","bind","SEASONS","NORTH_AMERICA","TEAM_COLORS","App","view","setView","onChange","overflow","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.91eaae36.chunk.js","sourcesContent":["import * as d3 from \"d3\";\nimport { concat, find, map, pickBy, reduce, some } from \"lodash\";\nimport moment from \"moment\";\nimport { CIRCLE_RADIUS } from \"./constants\";\nimport { Player, RlcsSeason, Tournament } from \"./types\";\nimport { TournamentPlayerNode } from \"./types/graph\";\n\n//// UTILITY\n\nexport const getNodeId = (...indices: number[]): string => indices.join(\"-\");\n\nexport const getNode = (id: string): TournamentPlayerNode =>\n  id.split(\"-\").reduce((acc, n, i) => {\n    acc[i === 0 ? \"tournamentIndex\" : i === 1 ? \"teamIndex\" : \"playerIndex\"] = +n;\n    return acc;\n  }, {} as TournamentPlayerNode);\n\nexport const getLinkElements = (chart: any, links: any[]) =>\n  chart\n    .append(\"g\")\n    .attr(\"stroke\", \"#999\")\n    .attr(\"stroke-opacity\", 0.6)\n    .selectAll(\"line\")\n    .data(links)\n    .join(\"line\");\n\nexport const nodeDrag = {\n  start: (simulation: any, d: d3.SimulationNodeDatum) => {\n    if (!d3.event.active) {\n      simulation.alphaTarget(0.3).restart();\n    }\n    d.fx = d.x;\n    d.fy = d.y;\n  },\n  in: (d: d3.SimulationNodeDatum) => {\n    d.fx = d3.event.x;\n    d.fy = d3.event.y;\n  },\n  end: (simulation: any, d: d3.SimulationNodeDatum) => {\n    if (!d3.event.active) {\n      simulation.alphaTarget(0);\n    }\n    d.fx = null;\n    d.fy = null;\n  },\n};\n\n// Used to set group curve for teams\nexport const valueline = d3\n  .line()\n  .x((d) => d[0])\n  .y((d) => d[1])\n  .curve(d3.curveCatmullRomClosed);\n\n// Data managing\nexport const tournamentsToPlayerNodes = (tournaments: Tournament[]) => {\n  return reduce(\n    tournaments,\n    (acc1, tournament, tournamentIndex) =>\n      concat(\n        acc1,\n        reduce(\n          tournament.teams,\n          (acc2, team, teamIndex) =>\n            // TODO eventually add subs\n            concat(\n              acc2,\n              reduce(\n                team.players,\n                (acc3, _player: string, playerIndex) =>\n                  concat(acc3, {\n                    tournamentIndex,\n                    teamIndex,\n                    playerIndex,\n                    id: getNodeId(tournamentIndex, teamIndex, playerIndex),\n                    x: 0,\n                    y: y({\n                      tournamentIndex,\n                      teamIndex,\n                      playerIndex,\n                      id: getNodeId(tournamentIndex, teamIndex, playerIndex),\n                    }), // teamIndex <= tournament.teams.length / 2 ? 0 : HEIGHT,\n                  }),\n                [] as TournamentPlayerNode[],\n              ),\n            ),\n          [] as TournamentPlayerNode[],\n        ),\n      ),\n    [] as TournamentPlayerNode[],\n  );\n};\n\nexport const LINK_FORCE = \"link\";\n\nexport const getPlayerName = (tournaments: Tournament[], d: TournamentPlayerNode) =>\n  tournaments[d.tournamentIndex].teams[d.teamIndex].players[d.playerIndex];\n\n// y depends on team and player index\nexport const y = (d: TournamentPlayerNode) => simpleY(d.teamIndex, d.playerIndex);\n\nexport const simpleY = (teamIndex: number, playerIndex: number, playersPerTeam = 5, buffer = 4) =>\n  // buffer\n  buffer * CIRCLE_RADIUS +\n  // team spacing\n  teamIndex * playersPerTeam * (2 * CIRCLE_RADIUS) +\n  // player spacing\n  playerIndex * (2 * CIRCLE_RADIUS);\n\nexport const tournamentAcronym = (name: string) =>\n  name.replaceAll(/[^A-Z0-9/]/g, \"\").replaceAll(\"/\", \" \");\n// .split(/[^A-Za-z0-9]/)\n// .map((word) => word[0])\n// .join(\"\");\n\nexport enum Viz {\n  SANKEY = \"sankey\",\n  TEAM_MAP = \"team-map\",\n  FORCE_GRAPH = \"force-graph\",\n  SIMPLE = \"simple\",\n  TABLE = \"table\",\n  TEXT = \"text\",\n  TIMELINE = \"timeline\",\n}\n\nexport const VizTitle = {\n  [Viz.SANKEY]: \"Sankey\",\n  [Viz.TEAM_MAP]: \"Team Map\",\n  [Viz.FORCE_GRAPH]: \"Force Graph\",\n  [Viz.SIMPLE]: \"Simple\",\n  [Viz.TABLE]: \"Table\",\n  [Viz.TEXT]: \"Text\",\n  [Viz.TIMELINE]: \"Timeline\",\n};\n\n// Map numerical enum\nexport const mapEnum = (x: any, iter: (val: number, key: string) => any) => {\n  return map(\n    pickBy(x, (val) => {\n      return typeof val === \"number\";\n    }),\n    iter,\n  );\n};\n\nexport const DATE_FORMAT = \"YYYY-MM-DD\";\n\nexport const toDate = (d: string): Date => moment(d, DATE_FORMAT).toDate();\n\nconst COLOR_UNKNOWN_TEAM = \"#232323\";\n\nexport const getTeamColor = (team: string, teams: Record<string, string>) =>\n  team in teams ? teams[team] : COLOR_UNKNOWN_TEAM;\n\n// TODO add an option so we evenly space out each section instead of scaling by the length of each\n// disjoint time block\nexport class ScaleTimeDisjoint {\n  public dateDiffs: number[];\n  public totalDiff: number = 0;\n  public domain: Array<[string, string]>;\n  public range: [number, number];\n\n  // domain needs to be increasing order, each element needs to be 0 < 1\n  constructor(domain: Array<[string, string]>, range: [number, number]) {\n    // Calculate the date ranges involved in each\n    this.dateDiffs = map(domain, (r) => {\n      // Add 1 because we're calculating the length of the tournament in days.\n      const diff = moment(r[1]).diff(moment(r[0]), \"days\"); // + 1;\n      this.totalDiff += diff;\n      return diff;\n    });\n    this.domain = domain;\n    this.range = range;\n  }\n\n  public convert(input: string) {\n    let output = this.range[0];\n\n    // Find the date range index that we live in\n    some(this.domain, (r, i) => {\n      const totalX = (this.dateDiffs[i] / this.totalDiff) * (this.range[1] - this.range[0]);\n      if (r[0] <= input && input <= r[1]) {\n        // Add our local diff\n        const localDiff = moment(input).diff(moment(r[0]), \"days\");\n        output += (localDiff / this.dateDiffs[i]) * totalX;\n        return true;\n      }\n      output += totalX;\n    });\n\n    return output;\n  }\n}\n\n// Get player by name or by alternate ID\nexport const findPlayer = (players: Player[], tname: string) => {\n  let player = find(players, (p) => p.name.toLowerCase() === tname.toLowerCase());\n  if (!player) {\n    player = find(\n      players,\n      (p) => !!find(p.alternateIDs, (i) => i.toLowerCase() === tname.toLowerCase()),\n    );\n    if (!player) {\n      console.log(\"Uh, didn't find a player... weird.\", tname);\n      return null;\n    }\n  }\n  return player;\n};\n\nexport function tournamentMap<T>(seasons: RlcsSeason[], func: (tournament: Tournament) => T) {\n  return reduce(\n    seasons,\n    (acc, s) => {\n      // Append from all sections\n      const sectionsMapped = reduce(\n        s.sections,\n        (acc2, sec) => {\n          // Append from all tournaments\n          return concat(\n            acc2,\n            map(sec.tournaments, (t) => {\n              return func(t);\n            }),\n          );\n        },\n        [] as T[],\n      );\n\n      return concat(acc, sectionsMapped);\n    },\n    [] as T[],\n  );\n}\n\nexport const WHITE = \"#fff\";\n\nexport const hexToColor = (hex: string): { r: number; g: number; b: number; a?: number } => {\n  hex = hex || WHITE;\n  // 3 digits\n  if (hex.length === 4) {\n    return {\n      r: parseInt(hex[1] + hex[1], 16),\n      g: parseInt(hex[2] + hex[2], 16),\n      b: parseInt(hex[3] + hex[3], 16),\n    };\n    // 4 digits\n  } else if (hex.length === 5) {\n    return {\n      r: parseInt(hex[1] + hex[1], 16),\n      g: parseInt(hex[2] + hex[2], 16),\n      b: parseInt(hex[3] + hex[3], 16),\n      a: parseInt(hex[4] + hex[4], 16),\n    };\n    // 6 digits\n  } else if (hex.length === 7) {\n    return {\n      r: parseInt(hex[1] + hex[2], 16),\n      g: parseInt(hex[3] + hex[4], 16),\n      b: parseInt(hex[5] + hex[6], 16),\n    };\n  }\n  return { r: 0, g: 0, b: 0 };\n};\n\n// FIXME Find the Stack Overflow answer that gave me this arbitrary formula\nexport function getColorByBackground(hex: string) {\n  const c = hexToColor(hex);\n  return c.r * 0.299 + c.g * 0.587 + c.b * 0.114 > 186 ? \"#000\" : \"#fff\";\n}\n\nexport function ordinalSuffixOf(i: number): string {\n  const j = i % 10,\n    k = i % 100;\n  if (j === 1 && k !== 11) {\n    return i + \"st\";\n  }\n  if (j === 2 && k !== 12) {\n    return i + \"nd\";\n  }\n  if (j === 3 && k !== 13) {\n    return i + \"rd\";\n  }\n  return i + \"th\";\n}\n","// Constants\nexport const WIDTH = 1600;\nexport const HEIGHT = 1050;\nexport const MARGIN = 25;\nexport const CIRCLE_RADIUS = 10;\nexport const SPACING = 10;\n","import { scaleLinear } from \"d3-scale\";\nimport { concat, forEach, intersection, map, reduce, size, sortBy } from \"lodash\";\nimport React from \"react\";\nimport { CIRCLE_RADIUS, HEIGHT, WIDTH } from \"../constants\";\nimport { RlcsSeason, Team, Tournament } from \"../types\";\nimport { TournamentLink, TournamentPlayerNode } from \"../types/graph\";\nimport {\n  getNodeId,\n  tournamentsToPlayerNodes,\n  y,\n  getPlayerName,\n  tournamentAcronym,\n  tournamentMap,\n} from \"../util\";\n\n// Based on adjacent tournaments, shuffle teams so that teams with more shared players are\n// vertically close together. Without this, a simple timeline is chaos. This basically brings us to\n// a healthy midpoint between plain timeline and a Sankey.\nconst sort = (tournaments: Tournament[]): Tournament[] => {\n  return map(tournaments, (tournament, index) => {\n    if (index === 0) {\n      return tournament;\n    }\n\n    const prevTourn = tournaments[index - 1];\n\n    let overflowIndex = size(prevTourn.teams);\n\n    // Pair of original index (0-based) and new index (1-based)\n    const indexPairs = map(tournament.teams, (team, teamIndex) => {\n      let newIndex =\n        reduce(\n          prevTourn.teams,\n          (acc, prevTeam, prevTeamIndex) => {\n            // Here if size == 0, we should return the overflowIndex, yeah?\n            return acc + (prevTeamIndex + 1) * size(intersection(prevTeam.players, team.players));\n          },\n          0,\n        ) / size(team.players);\n\n      if (newIndex === 0) {\n        newIndex = overflowIndex++;\n      }\n      return {\n        originalIndex: teamIndex,\n        newIndex,\n      };\n    });\n\n    const sortedIndexPairs = sortBy(indexPairs, [\"newIndex\"]);\n\n    const newTeams: Team[] = [];\n\n    forEach(sortedIndexPairs, (pair) => {\n      newTeams.push({\n        ...tournament.teams[pair.originalIndex],\n        metadata: JSON.stringify(pair),\n      });\n    });\n\n    tournament.teams = newTeams;\n\n    return tournament;\n  });\n};\n\nconst process = (t: Tournament[]): { nodes: TournamentPlayerNode[]; links: TournamentLink[] } => {\n  const tournaments = sort(t);\n\n  // First, collect all nodes for all tournaments\n  const allNodes = tournamentsToPlayerNodes(t);\n\n  // Basically we want a full list of links with source and target both being an index 3-tuple\n  const inverseMap: Record<string, TournamentPlayerNode[]> = {};\n  forEach(tournaments, (tournament, tournamentIndex) => {\n    forEach(tournament.teams, (team, teamIndex) => {\n      // // Same team + same tournament TODO uncomment eventually\n      // sameTeamSameTournamentLinks.push(\n      //   ...comb.combination(range(team.players.length), 2).map((pair) => ({\n      //     source: getNodeId(tournamentIndex, teamIndex, pair[0]),\n      //     target: getNodeId(tournamentIndex, teamIndex, pair[1]),\n      //   })),\n      // );\n\n      forEach(team.players, (player, playerIndex) => {\n        if (!(player in inverseMap)) {\n          inverseMap[player] = [];\n        }\n        inverseMap[player].push({\n          playerIndex,\n          teamIndex,\n          tournamentIndex,\n          id: getNodeId(tournamentIndex, teamIndex, playerIndex),\n        });\n      });\n    });\n  });\n\n  // Compress inverseMap into all links\n  const samePlayerLinks = reduce(\n    inverseMap,\n    (acc, nodes) => {\n      // Combine nodes into an array of links\n      const links = [];\n      for (let i = 0; i < nodes.length - 1; i++) {\n        links.push({\n          source: nodes[i], // getNodeId(nodes[i].tournamentIndex, nodes[i].teamIndex, nodes[i].playerIndex),\n          target: nodes[i + 1], // getNodeId( nodes[i + 1].tournamentIndex, nodes[i + 1].teamIndex, nodes[i + 1].playerIndex,),\n        });\n      }\n      return concat(acc, links);\n    },\n    [] as TournamentLink[],\n  );\n\n  // allTeams = reduce(\n  //   tournaments,\n  //   (acc, tournament, tournamentIndex) =>\n  //     concat(\n  //       acc,\n  //       map(tournament.teams, (team) => ({ ...team, tournamentIndex })),\n  //     ),\n  //   [],\n  // );\n\n  return { nodes: allNodes, links: samePlayerLinks };\n};\n\nconst randDiv = () => 0.5; // Math.random() * 0.6 + 0.2;\n\nexport default function SimpleGraph({ seasons }: { seasons: RlcsSeason[] }) {\n  const tournaments = tournamentMap(seasons, (t) => t);\n\n  const x = scaleLinear()\n    .domain([0, tournaments.length])\n    .range([15 * CIRCLE_RADIUS + CIRCLE_RADIUS, WIDTH - CIRCLE_RADIUS]);\n\n  const getD = (d: TournamentLink) => {\n    const sx = x(d.source.tournamentIndex);\n    const sy = y(d.source);\n    const tx = x(d.target.tournamentIndex);\n    const ty = y(d.target);\n\n    const xmid = sx + (tx - sx) * randDiv();\n    const ymid = sy + (ty - sy) * randDiv();\n\n    return `M ${sx} ${sy} C ${xmid} ${sy}, ${xmid} ${sy}, ${xmid} ${ymid} S ${xmid} ${ty}, ${tx} ${ty}`;\n  };\n\n  const data = process(tournaments);\n\n  return (\n    <svg width={WIDTH} height={HEIGHT}>\n      <g id=\"nodes\">\n        {map(data.nodes, (d) => (\n          <g key={d.id}>\n            <circle cx={x(d.tournamentIndex)} cy={y(d)} r={CIRCLE_RADIUS} />\n            <text\n              textAnchor=\"end\"\n              x={x(d.tournamentIndex) - CIRCLE_RADIUS - CIRCLE_RADIUS / 2}\n              y={y(d) + CIRCLE_RADIUS / 2}\n            >\n              {getPlayerName(tournaments, d)}\n            </text>\n          </g>\n        ))}\n      </g>\n      <g id=\"links\">\n        {map(data.links, (d) => (\n          <path\n            key={`${d.source.id}-${d.target.id}`}\n            d={getD(d)}\n            fill=\"transparent\"\n            stroke=\"black\"\n          />\n        ))}\n      </g>\n      <g id=\"tournament-titles\">\n        {map(tournaments, (t, i) => (\n          <text x={x(i)} y=\"1em\" textAnchor=\"middle\" key={i}>\n            {tournamentAcronym(t.name)}\n          </text>\n        ))}\n      </g>\n    </svg>\n  );\n}\n","import { Player } from \"../../types\";\n\nexport const PLAYERS = [\n  {\n    memberships: [\n      {\n        join: \"2021-01-01\",\n        team: \"Team 1\",\n      },\n    ],\n    name: \"Player 1\",\n  },\n  {\n    memberships: [\n      {\n        join: \"2021-01-01\",\n        team: \"Team 1\",\n      },\n    ],\n    name: \"Player 2\",\n  },\n  {\n    memberships: [\n      {\n        join: \"2021-01-01\",\n        leave: \"2021-02-15\",\n        team: \"Team 1\",\n      },\n      {\n        join: \"2021-02-16\",\n        team: \"Team 2\",\n      },\n    ],\n    name: \"Player 3\",\n  },\n  {\n    memberships: [\n      {\n        join: \"2021-01-01\",\n        leave: \"2021-02-17\",\n        team: \"Team 2\",\n      },\n      {\n        join: \"2021-02-20\",\n        team: \"Team 1\",\n      },\n    ],\n    name: \"Player 4\",\n  },\n  {\n    memberships: [\n      {\n        join: \"2021-01-05\",\n        team: \"Team 2\",\n      },\n    ],\n    name: \"Player 5\",\n  },\n  {\n    memberships: [\n      {\n        join: \"2021-01-06\",\n        team: \"Team 2\",\n      },\n    ],\n    name: \"Player 6\",\n  },\n] as Player[];\n","export interface Team {\n  name: string;\n  // TODO: do we need this? we should piece together membership from player events\n  players: string[];\n  subs?: string[] | null;\n  region: Region;\n  metadata?: any;\n  won?: boolean;\n}\n\nexport interface Tournament {\n  region: Region;\n  name: string;\n  start: string;\n  end: string;\n  teams: Team[];\n}\n\nexport interface Section {\n  name: string;\n  tournaments: Tournament[];\n}\n\nexport interface RlcsSeason {\n  season: string;\n  sections: Section[];\n}\n\n// TODO remove \"WORLD\" and replace with a collection of regions\nexport enum Region {\n  NONE,\n  WORLD,\n  NORTH_AMERICA,\n  EUROPE,\n  OCEANIA,\n  SOUTH_AMERICA,\n}\n\nexport interface Membership {\n  team: string;\n  join: string;\n  leave?: string;\n}\n\nexport interface Player {\n  name: string;\n  memberships: Membership[];\n  alternateIDs?: string[] | null;\n}\n\nexport enum EventType {\n  JOIN = \"join\",\n  LEAVE = \"leave\",\n}\n","import { scaleTime } from \"d3-scale\";\nimport { assign, concat, find, forEach, isNull, map, range, reduce, size } from \"lodash\";\nimport moment, { Moment } from \"moment\";\nimport React from \"react\";\nimport { CIRCLE_RADIUS, MARGIN, SPACING } from \"../constants\";\nimport { PLAYERS } from \"../data/sample/players\";\nimport { EventType, Player, RlcsSeason, Tournament } from \"../types\";\nimport {\n  DATE_FORMAT,\n  findPlayer,\n  getTeamColor,\n  toDate,\n  tournamentAcronym,\n  tournamentMap,\n} from \"../util\";\n\nconst BIG_WIDTH = 1200; // 5500;\n// const BIG_HEIGHT = 2500;\n\nconst TIMELINE_BUFFER = 10;\nconst TIMELINE_SPACE = 10 * SPACING;\n\nconst Radius = {\n  [EventType.JOIN]: 4,\n  [EventType.LEAVE]: 6,\n};\nconst FILL_LEAVE = \"transparent\";\nconst COLOR_NO_TEAM = \"#bbbbbb\";\nconst STROKE_WIDTH_TEAM = 3;\n\n// Three inputs:\n// - player events: join/leave team\n//    - teams are evaluated based on the ones that participated in the tournaments\n// - team info: colors, date range\n// - tournaments: participants (team names could change), winners\n\n// getIndices sets up a record with lowercased mapping. It also includes alternate ID's.\n// TODO this logic is shared between here and Table.tsx\nconst getIndices = (players: Player[]): Record<string, number> => {\n  let idx = 0;\n  return reduce(\n    players,\n    (acc, p) => {\n      const myPart = {} as Record<string, number>;\n      const myIndex = idx++;\n      if (p.name.toLowerCase() in acc) {\n        console.warn(\"ERROR ERROR DUPLICATE PLAYER!\", p, \"BUT WE PRIMARY SO WE BETTER!\");\n      }\n      myPart[p.name.toLowerCase()] = myIndex;\n      forEach(p.alternateIDs, (name) => {\n        if (name.toLowerCase() in acc) {\n          console.error(\"ERROR ERROR DUPLICATE PLAYER!\", p, \"LEAVING IT IN!\");\n        } else {\n          myPart[name.toLowerCase()] = myIndex;\n        }\n      });\n      return assign(acc, myPart);\n    },\n    {} as Record<string, number>,\n  );\n};\n\n// Contract: each player's events are always sorted in time order. Tournaments are sorted.\nexport default function Timeline({\n  seasons,\n  players,\n  teamColors,\n}: {\n  seasons: RlcsSeason[];\n  players: Player[];\n  teamColors: Record<string, string>;\n}) {\n  if (size(seasons) === 0) {\n    return <div>Loading...</div>;\n  }\n\n  const indices = getIndices(players);\n\n  // Given a vertical index, what's its Y coordinate?\n  const y = (index: number) => TIMELINE_SPACE + index * 2 * SPACING;\n\n  // Most important function: given an event # and player, get its Y coordinate.\n  // We want to be as flexible as possible here, pname could be the main name, case-insensitive, or\n  // alternate ID\n  const getY = (pname: string, _eventNum?: number, _eventType?: EventType) => {\n    // indices should be fully permissive for all lowercase, so a simple check suffices here.\n    if (!(pname.toLowerCase() in indices)) {\n      return null;\n    }\n\n    return y(indices[pname.toLowerCase()]);\n  };\n\n  console.log(PLAYERS);\n\n  // Calculating minimum and maximum:\n  // [min/max] Try 1: events\n  // Start is the earliest join of any player\n  const start = players?.reduce((acc, cur) => {\n    return !acc || cur.memberships[0]?.join < acc ? cur.memberships[0]?.join : acc;\n  }, \"\");\n  // End is the latest leave of any player, or now if there are no leaves\n  const end = players?.reduce((acc, cur) => {\n    const interim =\n      cur.memberships?.length > 0 && cur.memberships[cur.memberships.length - 1].leave;\n    const candidate = interim || moment().format(DATE_FORMAT);\n    return !acc || candidate > acc ? candidate : acc;\n  }, \"\");\n\n  console.log(\"start\", start, \"end\", end);\n\n  if (!start || !end) {\n    return (\n      <b>\n        Somethin's wrong! start {JSON.stringify(start)} or end {JSON.stringify(end)} are undefined\n      </b>\n    );\n  }\n\n  // [min/max] Try 2: tournaments\n  // startDate = startDate > tournaments[0].start ? tournaments[0].start : startDate;\n  // endDate = endDate < last(tournaments)!.end ? last(tournaments)!.end : endDate;\n\n  const x = scaleTime()\n    .domain([toDate(start), toDate(end)])\n    .range([MARGIN * 3, BIG_WIDTH - MARGIN]);\n\n  const TimelineDate = ({ now }: { now: Moment }) => (\n    <text\n      x={x(now.toDate())}\n      y={CIRCLE_RADIUS}\n      transform={`rotate(90,${x(now.toDate())},${CIRCLE_RADIUS})`}\n      // textLength={(d.y1 || 0) - (d.y0 || 0)}\n      // lengthAdjust=\"spacing\"\n    >\n      {now.format(DATE_FORMAT)}\n    </text>\n  );\n\n  function TournamentComponent({ tournament: t }: { tournament: Tournament }) {\n    const thisX = x(toDate(t.start));\n    const thisWidth = x(toDate(t.end)) - x(toDate(t.start));\n\n    return (\n      <g key={t.name}>\n        <rect x={thisX} y={0} width={thisWidth} height={y(size(indices))} opacity={0.2} />\n        <text\n          x={thisX + thisWidth / 2}\n          y={TIMELINE_BUFFER * CIRCLE_RADIUS}\n          transform={`rotate(90,${thisX + thisWidth / 2},${TIMELINE_BUFFER * CIRCLE_RADIUS})`}\n          // textLength={BIG_HEIGHT - TIMELINE_BUFFER * CIRCLE_RADIUS}\n          // lengthAdjust=\"spacing\"\n        >\n          {tournamentAcronym(t.name)}\n        </text>\n        {reduce(\n          t.teams,\n          (acc3, team) => {\n            return concat(\n              acc3,\n              map(team.players, (p) => {\n                const myY = getY(p);\n                if (isNull(myY)) {\n                  console.error(\"couldn't find player\", p);\n                  return undefined;\n                }\n\n                // Sanity check\n                const player = findPlayer(players, p);\n                if (player) {\n                  const memb = find(\n                    player.memberships,\n                    (m) => m.join <= t.end && (!m.leave || m.leave >= t.start),\n                  );\n                  if (!memb) {\n                    console.error(\n                      \"couldn't find membership for\",\n                      p,\n                      \"for tournament\",\n                      t.name,\n                      \"and team\",\n                      team.name,\n                    );\n                  }\n                } else {\n                  console.error(\"couldn't find player, but found Y... weird\", p);\n                }\n\n                return (\n                  <rect\n                    key={p}\n                    x={thisX}\n                    y={myY - CIRCLE_RADIUS / 2 - STROKE_WIDTH_TEAM / 2}\n                    width={thisWidth}\n                    height={CIRCLE_RADIUS + STROKE_WIDTH_TEAM}\n                    opacity={0.3}\n                    fill=\"maroon\"\n                  >\n                    <title>\n                      {p} * {team.name}\n                    </title>\n                  </rect>\n                );\n              }),\n            );\n          },\n          [] as any[],\n        )}\n      </g>\n    );\n  }\n\n  function PlayerComponent({ player }: { player: Player }) {\n    // TODO filter out players that don't have tournaments visible in the view rn\n    // Processing a single player's events, we can produce the nodes and links in one iteration\n    const elements = reduce(\n      player.memberships,\n      (acc, mem, idx) => {\n        const color = getTeamColor(mem.team, teamColors);\n\n        // Join\n        const joinX = x(toDate(mem.join));\n        const joinY = getY(player.name, idx, EventType.JOIN)!;\n        const circ = (\n          <circle\n            key={`${player.name}-join-${idx}`}\n            id={`${player.name}-join-${mem.team}`}\n            data-date={mem.join}\n            cx={joinX}\n            cy={joinY}\n            r={Radius[EventType.JOIN]}\n            stroke={color}\n            fill={color}\n          />\n        );\n        acc.push(\n          idx === 0 ? (\n            <g key=\"playername\">\n              {circ}\n              <text textAnchor=\"end\" x={joinX - SPACING} y={joinY + SPACING / 2}>\n                {player.name}\n              </text>\n            </g>\n          ) : (\n            circ\n          ),\n        );\n\n        // Link backward between events\n        if (idx !== 0) {\n          const prevLeaveX = x(toDate(player.memberships[idx - 1].leave!));\n          const prevLeaveY = getY(player.name, idx, EventType.LEAVE)!;\n\n          acc.push(\n            <line\n              key={`${player.name}-teamless-${idx}`}\n              id={`${player.name}-teamless-${idx}`}\n              x1={prevLeaveX}\n              y1={prevLeaveY}\n              x2={joinX}\n              y2={joinY}\n              stroke={COLOR_NO_TEAM}\n            />,\n          );\n        }\n\n        // Leave?\n        const leaveX = x(toDate(mem.leave || end));\n        const leaveY = getY(player.name, idx, EventType.LEAVE)!;\n        if (mem.leave) {\n          acc.push(\n            <circle\n              key={`${player.name}-leave-${idx}`}\n              id={`${player.name}-leave-${mem.team}`}\n              data-date={mem.leave}\n              cx={leaveX}\n              cy={leaveY}\n              r={Radius[EventType.LEAVE]}\n              stroke={color}\n              fill={FILL_LEAVE}\n            />,\n          );\n        }\n\n        acc.push(\n          <line\n            key={`${player.name}-team-${idx}`}\n            id={`${player.name}-team-${mem.team}`}\n            x1={joinX}\n            y1={joinY}\n            x2={leaveX}\n            y2={leaveY}\n            stroke={color}\n            strokeWidth={STROKE_WIDTH_TEAM}\n          >\n            <title>\n              {player.name} | {mem.team}\n            </title>\n          </line>,\n        );\n\n        return acc;\n      },\n      [] as any[],\n    );\n\n    return <>{elements}</>;\n  }\n\n  return (\n    <svg width={BIG_WIDTH} height={y(size(indices))}>\n      <g id=\"tournaments\">\n        {tournamentMap(seasons, (t) => (\n          <TournamentComponent tournament={t} />\n        ))}\n      </g>\n      <g id=\"timeline\">\n        {map(range(0, moment(end).diff(start, \"d\"), 50), (days, i) => (\n          <TimelineDate key={i} now={moment(start).add(days, \"d\")} />\n        ))}\n        {tournamentMap(seasons, (t) => (\n          <React.Fragment key={t.name}>\n            <TimelineDate now={moment(t.start)} />\n            <TimelineDate now={moment(t.end)} />\n          </React.Fragment>\n        ))}\n      </g>\n      <g id=\"events\">\n        {map(players, (player) => (\n          <PlayerComponent key={player.name} player={player} />\n        ))}\n      </g>\n    </svg>\n  );\n}\n","import { interpolateOrRd } from \"d3\";\nimport { forEach, map, reduce, size, sum, values } from \"lodash\";\nimport React, { useMemo } from \"react\";\nimport { RlcsSeason, Tournament } from \"../types\";\nimport { ordinalSuffixOf, tournamentAcronym, tournamentMap } from \"../util\";\n\nconst process = (tournaments: Tournament[]) => {\n  const seasonMap = {} as Record<string, number>;\n\n  return map(tournaments, (t) => {\n    const seasonCounts = {} as Record<string, number>;\n\n    forEach(t.teams, (team) => {\n      forEach(team.players, (player) => {\n        if (!(player in seasonMap)) {\n          seasonMap[player] = 1;\n        } else {\n          seasonMap[player]++;\n        }\n        seasonCounts[player] = seasonMap[player];\n      });\n    });\n\n    return {\n      tournament: t,\n      seasonCounts,\n    };\n  });\n};\n\nconst rookiePercentage = (seasonCounts: Record<string, number>) => {\n  const [rookies, nonRookies] = reduce(\n    seasonCounts,\n    (acc, cur) => {\n      acc[cur === 1 ? 0 : 1]++;\n      return acc;\n    },\n    [0, 0],\n  );\n  return (100 * rookies) / (rookies + nonRookies);\n};\n\nconst average = (seasonCounts: Record<string, number>) => {\n  return sum(values(seasonCounts)) / size(seasonCounts);\n};\n\nexport default function Text({ seasons }: { seasons: RlcsSeason[] }) {\n  const tournaments = useMemo(() => tournamentMap(seasons, (t) => t), [seasons]);\n\n  const processed = process(tournaments);\n\n  return (\n    <table>\n      <tbody>\n        <tr>\n          <th />\n          {map(tournaments, (t, i) => (\n            <th key={i}>{tournamentAcronym(t.name)}</th>\n          ))}\n        </tr>\n        <tr style={{ textAlign: \"center\" }}>\n          <td>Percentage of rookies</td>\n          {map(processed, ({ seasonCounts }) => (\n            <td>{Math.round(rookiePercentage(seasonCounts) * 100) / 100}</td>\n          ))}\n        </tr>\n        <tr style={{ textAlign: \"center\" }}>\n          <td>Average age</td>\n          {map(processed, ({ seasonCounts }) => (\n            <td>{ordinalSuffixOf(Math.round(average(seasonCounts) * 100) / 100)}</td>\n          ))}\n        </tr>\n        <tr>\n          <td>Details</td>\n          {map(processed, ({ tournament: t, seasonCounts }) => (\n            <td>\n              <ul>\n                {map(t.teams, (team) => (\n                  <>\n                    <li>{team.name}</li>\n                    <ul>\n                      {map(team.players, (p) => (\n                        <li\n                          style={{\n                            backgroundColor: interpolateOrRd(seasonCounts[p] / size(tournaments)),\n                          }}\n                        >\n                          {p}: <b>{seasonCounts[p]}th season</b>\n                        </li>\n                      ))}\n                    </ul>\n                  </>\n                ))}\n              </ul>\n            </td>\n          ))}\n        </tr>\n      </tbody>\n    </table>\n  );\n}\n","import { sankey, SankeyLink, sankeyLinkHorizontal, SankeyNode } from \"d3-sankey\";\nimport { find, forEach, get, map } from \"lodash\";\nimport React, { useMemo } from \"react\";\nimport { HEIGHT, WIDTH } from \"../constants\";\nimport { RlcsSeason, Tournament } from \"../types\";\nimport { tournamentMap } from \"../util\";\n\n// These properties are on top of the node and link properties Sankey provides\ninterface TeamNode {\n  name: string;\n  tournamentIndex: number;\n  date?: string;\n}\n\ninterface PlayerLink {\n  player: string;\n}\n\nconst NONE_TEAM = \"NONE\";\n\nconst findTeamForPlayer = (tourney: Tournament, player: string) =>\n  get(\n    find(tourney.teams, (t) => find(t.players, (p) => p === player)),\n    \"name\",\n    NONE_TEAM,\n  );\n\nconst getNodeId = (d: TeamNode) => `${d.name}-${d.tournamentIndex}`;\n\nconst processTournaments = (tournaments: Tournament[]) => {\n  // Nodes are each team.\n  // Links are players\n  const nodes: Array<SankeyNode<TeamNode, PlayerLink>> = [];\n  const links: Array<SankeyLink<TeamNode, PlayerLink>> = [];\n  // Collect all relevant players\n  const allPlayers = new Set<string>();\n\n  let minDate: string = \"\",\n    maxDate: string = \"\";\n\n  forEach(tournaments, (tourney, tournamentIndex) => {\n    // Add nodes for each team\n    forEach(tourney.teams, (team) => {\n      nodes.push({ name: team.name, tournamentIndex, date: tourney.start });\n      map(team.players, (p) => allPlayers.add(p));\n    });\n    // Add the none\n    nodes.push({ name: NONE_TEAM, tournamentIndex, date: tourney.start });\n\n    // Update min/max dates\n    if (!minDate || tourney.start < minDate) {\n      minDate = tourney.start;\n    }\n    if (!maxDate || tourney.start > maxDate) {\n      maxDate = tourney.start;\n    }\n  });\n\n  forEach(tournaments.slice(0, tournaments.length - 1), (tourney, tournamentIndex) => {\n    const tournamentPlayers = new Set(allPlayers);\n\n    // Go through each player in each team and compose source/target\n    forEach(tourney.teams, (team) => {\n      // First add all players that are actually here\n      forEach(team.players, (player) => {\n        links.push({\n          source: getNodeId({ name: team.name, tournamentIndex }),\n          target: getNodeId({\n            name: findTeamForPlayer(tournaments[tournamentIndex + 1], player),\n            tournamentIndex: tournamentIndex + 1,\n          }),\n          value: 1,\n          player,\n        });\n        tournamentPlayers.delete(player);\n      });\n    });\n    // Then all of the others\n    tournamentPlayers.forEach((player) =>\n      links.push({\n        source: getNodeId({ name: NONE_TEAM, tournamentIndex }),\n        target: getNodeId({\n          name: findTeamForPlayer(tournaments[tournamentIndex + 1], player),\n          tournamentIndex: tournamentIndex + 1,\n        }),\n        value: 1,\n        player,\n      }),\n    );\n  });\n\n  return { nodes, links, minDate, maxDate };\n};\n\nconst NODE_WIDTH = 20;\n\n// TODO hack because sankey's typedefs don't have linkSort atm\nconst sankeyCreator = (\n  sankey<TeamNode, PlayerLink>()\n    .size([WIDTH, HEIGHT])\n    .nodeId(getNodeId)\n    .nodeWidth(NODE_WIDTH)\n    .nodePadding(10)\n    .nodeAlign((d) => {\n      return get(d, \"tournamentIndex\");\n    })\n    .nodeSort((a, b) => {\n      if (a.name.startsWith(NONE_TEAM)) {\n        return 1;\n      } else if (b.name.startsWith(NONE_TEAM)) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }) as any\n).linkSort((a: any, b: any) => {\n  return get(a, \"player\") - get(b, \"player\");\n});\n\nexport default function Sankey({ seasons }: { seasons: RlcsSeason[] }) {\n  const tournaments = useMemo(() => tournamentMap(seasons, (t) => t), [seasons]);\n\n  const data = processTournaments(tournaments); // useMemo(() => processTournaments(tournaments), [tournaments]);\n\n  // .nodeAlign((d: TeamNode) => x(new Date(d.date || data.minDate)))\n\n  if (data.nodes.length > 0 && data.links.length > 0) {\n    sankeyCreator(data);\n  }\n\n  return (\n    <svg width={WIDTH} height={HEIGHT}>\n      <g id=\"links\" className=\"links\">\n        {map(data.links, (d: any) => (\n          <g>\n            <path\n              className=\"link\"\n              d={sankeyLinkHorizontal()(d) || \"\"}\n              fill=\"none\"\n              stroke=\"#606060\"\n              strokeWidth={d.width}\n              strokeOpacity={0.5}\n            >\n              <title>{d.player}</title>\n            </path>\n            <text x={get(d, \"source.x1\") + 5} y={d.y0}>\n              {d.player}\n            </text>\n            <text x={get(d, \"target.x0\") - 5} y={d.y1} textAnchor=\"end\">\n              {d.player}\n            </text>\n          </g>\n        ))}\n      </g>\n      <g id=\"nodes\">\n        {map(data.nodes, (d) => {\n          const t = {\n            x: (d.x0 || 0) + NODE_WIDTH / 2,\n            y: d.y1 || 0,\n          };\n          return (\n            <g>\n              <rect\n                className=\"node\"\n                x={d.x0}\n                y={d.y0}\n                width={(d.x1 || 0) - (d.x0 || 0)}\n                height={(d.y1 || 0) - (d.y0 || 0)}\n                fill={d.name.startsWith(NONE_TEAM) ? \"crimson\" : \"skyblue\"}\n                opacity={0.8}\n              />\n              <text\n                fontSize={10}\n                x={t.x}\n                y={t.y}\n                transform={`rotate(-90,${t.x},${t.y})`}\n                textLength={(d.y1 || 0) - (d.y0 || 0)}\n                lengthAdjust=\"spacing\"\n              >\n                {d.name}\n              </text>\n            </g>\n          );\n        })}\n      </g>\n    </svg>\n  );\n}\n","import {\n  assign,\n  find,\n  forEach,\n  has,\n  indexOf,\n  keys,\n  last,\n  map,\n  max,\n  min,\n  reduce,\n  size,\n} from \"lodash\";\nimport React from \"react\";\nimport { Player, Region, RlcsSeason } from \"../types\";\nimport { findPlayer, getColorByBackground, getTeamColor, ScaleTimeDisjoint } from \"../util\";\n\nconst SEASON_WIDTH = 600;\nconst X_OFFSET = 150;\nconst Y_OFFSET = 50;\nconst PLAYER_HEIGHT = 25;\nconst PADDING = 4;\nconst TEXT_OFFSET_X = 4;\nconst TEXT_OFFSET_Y = 6;\n\nconst BIG_HEIGHT = 3000;\n\n// Handle Season X gracefully\nconst getSeasonX = (s: string) => SEASON_WIDTH * (isNaN(parseInt(s, 10)) ? 9 : parseInt(s, 10) - 1);\n\n// Design\n// - For a given season, a player has to be strongly associated with a particular region. World region\n//   subsumes all other regions.\n// - We go tournament by tournament and append.\n//   - While appending, if the indices are adjacent and the previous block ends at the end, we can coalesce\nconst process = (seasons: RlcsSeason[], players: Player[]) =>\n  map(seasons, (season) => {\n    // Blocks are by season.\n    const playerBlocks: Record<string, { blocks: ParticipationBlock[]; region: Region }> = {};\n\n    forEach(season.sections, (section) => {\n      forEach(section.tournaments, (tourney) => {\n        const tourneyDone: Record<string, boolean> = {};\n\n        // TODO implement\n        // The blocks for this tournament are governed by the same rules as filterByTournament in\n        // players.go.\n        // Build up a map from player to list of blocks, with the last team match\n        // const tournamentBlocks: Record<\n        //   string,\n        //   { blocks: ParticipationBlock[]; lastTeamMatch: number }\n        // > = {};\n\n        forEach(tourney.teams, (team) => {\n          forEach(team.players, (tname) => {\n            // Find the event(s) relevant to this tournament by date.\n            const player = findPlayer(players, tname);\n\n            if (player) {\n              const name = player.name;\n              forEach(player.memberships, (mem) => {\n                if (\n                  !tourneyDone[name] &&\n                  mem.join <= tourney.end &&\n                  (!mem.leave || mem.leave >= tourney.start)\n                ) {\n                  if (!has(playerBlocks, name)) {\n                    playerBlocks[name] = {\n                      region: team.region,\n                      blocks: [],\n                    };\n                  }\n\n                  const { blocks } = playerBlocks[name];\n                  // The simple case. We have overlap. Create block\n                  const start = max([tourney.start, mem.join])!;\n                  const fullStart = mem.join <= tourney.start;\n                  const end = mem.leave ? min([tourney.end, mem.leave])! : tourney.end;\n                  const fullEnd = !mem.leave || mem.leave >= tourney.end;\n\n                  // Try coalescing with last block. We can coalesce if the start of this and end of\n                  // previous line up.\n                  if (\n                    size(blocks) > 0 &&\n                    last(blocks)!.fullEnd &&\n                    fullStart &&\n                    last(blocks)!.team === mem.team\n                  ) {\n                    assign(last(blocks), {\n                      end,\n                      fullEnd,\n                    });\n                  } else {\n                    blocks.push({\n                      team: mem.team,\n                      start,\n                      end,\n                      fullStart,\n                      fullEnd,\n                    });\n                  }\n                  tourneyDone[name] = team.name === mem.team;\n                }\n              });\n            }\n          });\n        });\n      });\n    });\n\n    return playerBlocks;\n  });\n\n// TODO LAN\n\ninterface ParticipationBlock {\n  // player: string;\n  team: string;\n  // extend\n  fullStart: boolean;\n  fullEnd: boolean;\n  // dates (TODO remove)\n  start: string;\n  end: string;\n}\n\nexport default function Table({\n  seasons,\n  players,\n  teamColors,\n}: {\n  seasons: RlcsSeason[];\n  players: Player[];\n  teamColors: Record<string, string>;\n}) {\n  // Convert tournaments + player info into \"participation blocks\" which have some properties, that\n  // will be then filtered on.\n  const seasonsData = process(seasons, players);\n  console.log(seasonsData);\n\n  // TODO who needs this when it's already the keys of various maps\n  const playerNames = Array.from<string>(\n    reduce(\n      seasonsData,\n      (acc, cur) => {\n        forEach(keys(cur), (p) => acc.add(p));\n        return acc;\n      },\n      new Set(),\n    ),\n  );\n\n  return (\n    <svg height={BIG_HEIGHT} width={SEASON_WIDTH * size(seasonsData) + X_OFFSET}>\n      <g id=\"seasons\">\n        {map(seasons, (s, i) => (\n          <>\n            <g id={`season-title-${s.season}`}>\n              <rect\n                x={X_OFFSET + SEASON_WIDTH * i}\n                y={0}\n                width={SEASON_WIDTH}\n                height={Y_OFFSET}\n                fill=\"skyblue\"\n              />\n              <text x={X_OFFSET + SEASON_WIDTH * i + TEXT_OFFSET_X} y={Y_OFFSET - TEXT_OFFSET_Y}>\n                Season {s.season}\n              </text>\n            </g>\n            <g id={`season-lines-${s.season}`}>\n              {[i, i + 1].map((j) => (\n                <line\n                  stroke=\"black\"\n                  x1={X_OFFSET + SEASON_WIDTH * j}\n                  y1={0}\n                  x2={X_OFFSET + SEASON_WIDTH * j}\n                  y2={BIG_HEIGHT}\n                />\n              ))}\n            </g>\n          </>\n        ))}\n      </g>\n      <g id=\"player-names\">\n        {map(playerNames, (name, idx) => (\n          <g id={`player-name-${name}`}>\n            <rect\n              x={0}\n              y={Y_OFFSET + idx * PLAYER_HEIGHT}\n              width={X_OFFSET}\n              height={PLAYER_HEIGHT}\n              fill=\"transparent\"\n              stroke=\"black\"\n              strokeWidth={1}\n            />\n            <text x={TEXT_OFFSET_X} y={Y_OFFSET + (idx + 1) * PLAYER_HEIGHT - TEXT_OFFSET_Y}>\n              {name}\n            </text>\n          </g>\n        ))}\n      </g>\n      <g transform={`translate(${X_OFFSET},${Y_OFFSET})`} id=\"block-space\">\n        {map(seasonsData, (data, sIndex) => {\n          // Convert each player's blocks into reality.\n          const season = seasons[sIndex];\n          const baseX = getSeasonX(season.season);\n\n          return (\n            <g id={`block-space-season-${season.season}`}>\n              {map(data, (playerData, pname) => {\n                // This represents which region pname is competing in for this season. NOTE: No mid-season region transfers\n                // TODO put all assumptions in a central place somewhere so we know where to look if something breaks\n\n                // TODO all of this logic up till `scale` is just `season`+`region` based\n                const region = playerData.region;\n\n                // Get date offsets\n                const dates: Array<[string, string]> = [];\n                forEach(season.sections, (sec) => {\n                  // Find the relevant dates for this sec. Based on region.\n                  const relevantTourney =\n                    find(sec.tournaments, (t) => t.region === region) ||\n                    find(sec.tournaments, (t) => t.region === Region.WORLD);\n\n                  if (!relevantTourney) {\n                    console.error(\"No tourney found for this region. Rip.\");\n                  } else {\n                    dates.push([relevantTourney.start, relevantTourney.end]);\n                  }\n                });\n\n                const scale = new ScaleTimeDisjoint(dates, [0, SEASON_WIDTH]);\n\n                return (\n                  <g id={`block-space-season-${seasons[sIndex].season}-player-${pname}`}>\n                    {map(playerData.blocks, (b) => {\n                      // TODO include alternate ID's here\n                      const y = indexOf(playerNames, pname) * PLAYER_HEIGHT;\n\n                      const startX = scale.convert(b.start);\n                      const endX = scale.convert(b.end);\n\n                      const color = getTeamColor(b.team, teamColors);\n\n                      return (\n                        <g>\n                          <rect\n                            x={baseX + startX + PADDING / 2}\n                            y={y + PADDING / 2}\n                            width={endX - startX - PADDING}\n                            height={PLAYER_HEIGHT - PADDING}\n                            fill={color}\n                            opacity={0.7}\n                          />\n                          <text\n                            x={baseX + startX + TEXT_OFFSET_X}\n                            y={y + PLAYER_HEIGHT - TEXT_OFFSET_Y}\n                            fill={getColorByBackground(color)}\n                          >\n                            {b.team}\n                          </text>\n                        </g>\n                      );\n                    })}\n                  </g>\n                );\n              })}\n            </g>\n          );\n        })}\n      </g>\n    </svg>\n  );\n}\n","import * as d3 from \"d3-force\";\nimport { scaleLinear } from \"d3-scale\";\nimport { clamp, concat, forEach, get, map, reduce } from \"lodash\";\nimport React, { useMemo, useState } from \"react\";\nimport { useUpdate } from \"react-use\";\nimport { CIRCLE_RADIUS, HEIGHT, WIDTH } from \"../constants\";\nimport { differentTeamForce, sameTeamForce } from \"../forces\";\nimport { RlcsSeason, Tournament } from \"../types\";\nimport { SimulationLink, TournamentPlayerNode } from \"../types/graph\";\nimport { getNodeId, getPlayerName, tournamentMap, tournamentsToPlayerNodes } from \"../util\";\n\nfunction processPlayerLinks(tournaments: Tournament[]) {\n  // Basically we want a full list of links with source and target both being an index 3-tuple\n  const inverseMap: Record<string, TournamentPlayerNode[]> = {};\n  forEach(tournaments, (tournament, tournamentIndex) => {\n    forEach(tournament.teams, (team, teamIndex) => {\n      // Same team + same tournament\n      forEach(team.players, (player, playerIndex) => {\n        if (!(player in inverseMap)) {\n          inverseMap[player] = [];\n        }\n        inverseMap[player].push({\n          playerIndex,\n          teamIndex,\n          tournamentIndex,\n          id: getNodeId(tournamentIndex, teamIndex, playerIndex),\n        });\n      });\n    });\n  });\n\n  // Compress inverseMap into all links\n  return reduce(\n    inverseMap,\n    (acc, nodes) => {\n      // Combine nodes into an array of links\n      const links = [];\n      for (let i = 0; i < nodes.length - 1; i++) {\n        // Note, these nodes aren't the same as the actual nodes\n        links.push({\n          source: getNodeId(nodes[i].tournamentIndex, nodes[i].teamIndex, nodes[i].playerIndex),\n          target: getNodeId(\n            nodes[i + 1].tournamentIndex,\n            nodes[i + 1].teamIndex,\n            nodes[i + 1].playerIndex,\n          ),\n        });\n      }\n      return concat(acc, links);\n    },\n    [] as SimulationLink[],\n  );\n}\n\nexport default function ForceGraph({ seasons }: { seasons: RlcsSeason[] }) {\n  const update = useUpdate();\n\n  const tournaments = useMemo(() => tournamentMap(seasons, (t) => t), [seasons]);\n\n  // drag state\n  const [dragNode, setDragNode] = useState<d3.SimulationNodeDatum | null>(null);\n  const [origin, setOrigin] = useState({ x: 0, y: 0 });\n  const [start, setStart] = useState({ x: 0, y: 0 });\n\n  // Process data\n  const playerNodes = useMemo(() => tournamentsToPlayerNodes(tournaments), [tournaments]);\n  const playerLinks = useMemo(() => processPlayerLinks(tournaments), [tournaments]);\n\n  const x = scaleLinear()\n    .domain([0, tournaments.length])\n    .range([15 * CIRCLE_RADIUS + CIRCLE_RADIUS, WIDTH - CIRCLE_RADIUS]);\n\n  const simulation = useMemo(\n    () =>\n      d3\n        .forceSimulation<TournamentPlayerNode>(playerNodes)\n        .force(\n          \"link\",\n          d3\n            .forceLink<TournamentPlayerNode, SimulationLink>()\n            .distance(WIDTH / 6) // N + 2\n            .id((d) => getNodeId(d.tournamentIndex, d.teamIndex, d.playerIndex))\n            .links(playerLinks),\n        )\n        .force(\"charge\", d3.forceManyBody().strength(-65))\n        .force(\"y\", d3.forceY(HEIGHT / 2).strength(0.01))\n        .force(\"collide\", d3.forceCollide(CIRCLE_RADIUS + 2))\n        .force(\"sameTeam\", sameTeamForce().strength(0.8))\n        .force(\"diffTeam\", differentTeamForce().strength(15))\n        .on(\"tick\", update),\n    [playerNodes, playerLinks, update],\n  );\n\n  // Triggered by mouse down on a node\n  const handleStartDrag = (\n    d: TournamentPlayerNode,\n    e: React.MouseEvent<SVGElement, MouseEvent>,\n  ) => {\n    simulation.alphaTarget(0.3).restart();\n\n    setDragNode(d);\n    setOrigin({ x: e.clientX, y: e.clientY });\n    setStart({ x: d.x || 0, y: d.y || 0 });\n\n    d.fx = d.x;\n    d.fy = d.y;\n  };\n\n  const handleDrag = (e: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (dragNode) {\n      dragNode.fx = start.x + e.clientX - origin.x;\n      dragNode.fy = start.y + e.clientY - origin.y;\n    }\n  };\n\n  const handleDoneDragging = () => {\n    if (dragNode) {\n      simulation.alphaTarget(0);\n      dragNode.fx = null;\n      dragNode.fy = null;\n    }\n    setDragNode(null);\n  };\n\n  return (\n    <svg width={WIDTH} height={HEIGHT} onMouseMove={handleDrag} onMouseUp={handleDoneDragging}>\n      <g id=\"nodes\">\n        {map(playerNodes, (d) => (\n          <g\n            key={d.id}\n            transform={`translate(${x(d.tournamentIndex)},${clamp(d.y || 0, 0, HEIGHT)})`}\n            onMouseDown={handleStartDrag.bind(null, d)}\n          >\n            <circle r={CIRCLE_RADIUS} />\n            <text x={CIRCLE_RADIUS + 1} y={3}>\n              {getPlayerName(tournaments, d)}\n            </text>\n          </g>\n        ))}\n      </g>\n      <g id=\"links\">\n        {map(playerLinks, (d) => (\n          <line\n            stroke=\"black\"\n            key={`${(d.source as TournamentPlayerNode).id}-${\n              (d.target as TournamentPlayerNode).id\n            }`}\n            x1={x((d.source as TournamentPlayerNode).tournamentIndex)}\n            y1={clamp(get(d, \"source.y\"), 0, HEIGHT)}\n            x2={x((d.target as TournamentPlayerNode).tournamentIndex)}\n            y2={clamp(get(d, \"target.y\"), 0, HEIGHT)}\n          />\n        ))}\n      </g>\n    </svg>\n  );\n}\n","import { concat, filter, forEach, map, partition, reduce, sortBy } from \"lodash\";\nimport { CIRCLE_RADIUS } from \"./constants\";\nimport { TournamentPlayerNode } from \"./types/graph\";\n\n// Pushes players on the same team into each other\nexport function sameTeamForce() {\n  let nodes: TournamentPlayerNode[];\n  let strength: number | ((d: TournamentPlayerNode) => number) = 1;\n\n  function getVel(desiredY: number, node: TournamentPlayerNode, alpha: number) {\n    // velocity due to this\n    return (\n      (desiredY - (node.y || 0)) *\n      (typeof strength === \"function\" ? strength(node) : strength) *\n      alpha\n    );\n  }\n\n  // Go through each of the forces and set some properties on the node\n  function force(alpha: number) {\n    forEach(nodes, (node) => {\n      // find the n other nodes in the same tournament with the same team.\n      // based on how many nodes there are, figure out what index of our team\n      // we want to become\n      const sameTeamNodes = partition(\n        sortBy(\n          filter(\n            nodes,\n            (n) =>\n              n.tournamentIndex === node.tournamentIndex &&\n              n.teamIndex === node.teamIndex &&\n              n.playerIndex !== node.playerIndex,\n          ),\n          [\"y\"],\n        ),\n        (n) => (n.y || 0) <= (node.y || 0),\n      );\n\n      // read current positions and set new vx,vy\n      const velosUp = map(sameTeamNodes[0], (n, i, arr) => {\n        // desired position of node for this n is\n        const desiredY = (n.fy || n.y || 0) + 2 * CIRCLE_RADIUS * (arr.length - i);\n        return getVel(desiredY, node, alpha);\n      });\n      const velosDown = map(sameTeamNodes[1], (n, i) => {\n        // desired position of node for this n is\n        const desiredY = (n.fy || n.y || 0) - 2 * CIRCLE_RADIUS * (i + 1);\n        return getVel(desiredY, node, alpha);\n      });\n      const delVy = reduce(concat(velosDown, velosUp), (acc, cur) => acc + cur, 0);\n      node.vy = node.vy ? node.vy + delVy : delVy;\n    });\n  }\n\n  force.initialize = function (_: TournamentPlayerNode[]) {\n    nodes = _;\n  };\n\n  // TODO fix type\n  force.strength = function (_: number): any {\n    return arguments.length ? ((strength = typeof _ === \"function\" ? _ : +_), force) : strength;\n  };\n\n  return force;\n}\n\n// Pulls players on different teams apart\n// TODO doesn't work well\nexport function differentTeamForce() {\n  let nodes: TournamentPlayerNode[];\n  let strength: number | ((d: TournamentPlayerNode) => number) = 1;\n\n  function force(alpha: number) {\n    forEach(nodes, (node) => {\n      const differentTeamNodes = filter(\n        nodes,\n        (n) => n.tournamentIndex === node.tournamentIndex && n.teamIndex !== node.teamIndex,\n      );\n\n      const delVy = reduce(\n        differentTeamNodes,\n        (acc, cur) => {\n          const distance = (node.y || 0) - (cur.fy || cur.y || 0);\n          return (\n            acc +\n            (distance === 0\n              ? 0\n              : ((typeof strength === \"function\" ? strength(node) : strength) * alpha) / distance)\n          );\n        },\n        0,\n      );\n      node.vy = node.vy ? node.vy + delVy : delVy;\n    });\n  }\n\n  force.initialize = function (_: TournamentPlayerNode[]) {\n    nodes = _;\n  };\n\n  force.strength = function (_: number): any {\n    return arguments.length ? ((strength = typeof _ === \"function\" ? _ : +_), force) : strength;\n  };\n\n  return force;\n}\n","import { Region, RlcsSeason } from \"../../types\";\n\nexport const SEASONS = [\n  {\n    season: \"1\",\n    sections: [\n      {\n        name: \"Section 0\",\n        tournaments: [\n          {\n            region: Region.NORTH_AMERICA,\n            name: \"Season 1 Section 0 Tournament 0\",\n            start: \"2021-02-01\",\n            end: \"2021-02-10\",\n            teams: [\n              {\n                name: \"Team 1\",\n                players: [\"Player 1\", \"Player 2\", \"Player 3\"],\n                region: Region.NORTH_AMERICA,\n              },\n              {\n                name: \"Team 1\",\n                players: [\"Player 4\", \"Player 5\", \"Player 6\"],\n                region: Region.NORTH_AMERICA,\n              },\n            ],\n          },\n        ],\n      },\n      {\n        name: \"Section 1\",\n        tournaments: [\n          {\n            region: Region.NORTH_AMERICA,\n            name: \"Season 1 Section 1 Tournament 0\",\n            start: \"2021-03-01\",\n            end: \"2021-03-10\",\n            teams: [\n              {\n                name: \"Team 1\",\n                players: [\"Player 1\", \"Player 2\", \"Player 4\"],\n                region: Region.NORTH_AMERICA,\n              },\n              {\n                name: \"Team 2\",\n                players: [\"Player 3\", \"Player 5\", \"Player 6\"],\n                region: Region.NORTH_AMERICA,\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  },\n] as RlcsSeason[];\n","export const TEAM_COLORS = {\n  \"Team 1\": \"#802b26\",\n};\n","import { map } from \"lodash\";\nimport React, { useState } from \"react\";\nimport { Viz, VizTitle } from \"./util\";\nimport SimpleGraph from \"./viz/SimpleGraph\";\nimport Timeline from \"./viz/Timeline\";\nimport Text from \"./viz/Text\";\nimport Sankey from \"./viz/Sankey\";\nimport Table from \"./viz/Table\";\nimport ForceGraph from \"./viz/ForceGraph\";\n\n// import events from \"./data/players.json\";\n// import teams from \"./data/teams.json\";\n\nimport { SEASONS } from \"./data/sample/seasons\";\nimport { PLAYERS } from \"./data/sample/players\";\nimport { TEAM_COLORS } from \"./data/sample/team-colors\";\n\nfunction App() {\n  const [view, setView] = useState(Viz.TIMELINE);\n\n  const handleChange = (e: any) => {\n    console.log(e.target.value);\n    setView(e.target.value);\n  };\n\n  return (\n    <div>\n      <div style={{ textAlign: \"center\" }}>\n        <select value={view} onChange={handleChange}>\n          {map(Viz, (x) => (\n            <option value={x} key={x}>\n              {VizTitle[x]}\n            </option>\n          ))}\n        </select>\n        {/* <select value={map(regions, (r) => \"\" + r)} onChange={handleChangeRegion} multiple>\n          {mapEnum(Region, (x, name) => (\n            <option value={x} key={x}>\n              {name}\n            </option>\n          ))}\n        </select> */}\n      </div>\n      <div\n        style={{\n          width: \"100%\",\n          height: \"calc(100vh - 90px)\",\n          overflow: \"scroll\",\n        }}\n      >\n        {\n          view === Viz.SIMPLE ? (\n            <SimpleGraph seasons={SEASONS} />\n          ) : view === Viz.TIMELINE ? (\n            <Timeline seasons={SEASONS} players={PLAYERS} teamColors={TEAM_COLORS} />\n          ) : view === Viz.TABLE ? (\n            <Table seasons={SEASONS} players={PLAYERS} teamColors={TEAM_COLORS} />\n          ) : view === Viz.FORCE_GRAPH ? (\n            <ForceGraph seasons={SEASONS} />\n          ) : view === Viz.TEXT ? (\n            <Text seasons={SEASONS} />\n          ) : view === Viz.SANKEY ? (\n            <Sankey seasons={SEASONS} />\n          ) : (\n            \"\"\n          ) /*\n\n        ) : view === Viz.TEAM_MAP ? (\n          \"Hello\"\n        ) : // <PlayerTeams players={players} />\n        ) : view === Viz.TEXT ? (\n          <Text tournaments={chosenTournaments} />\n        ) : view === Viz.TIMELINE ? (\n          <Timeline seasons={seasons} players={events} teams={teams} />\n        ) : (\n          \"\"\n        )*/\n        }\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}